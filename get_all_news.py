# Добавляем в корень новый файл который ходить за новостями,
# ЗАЧЕМ??? - непонятно, т.к. и так при запуске самого Приложения,
# он и так ходит за новостями
#
# ОТВЕТ:
# "Работа с flask-sqlalchemy требует наличие flask app
# именно поэтому мы используем with app_context"
# "Чтобы использовать flask-sqlalchemy "отедльно" не из flask-приложения"
# Т.е., т.к. flask-sqlalchemy не может быть отдельной библотекой,
# для работы с sql, т.е. независимое построение запросов в базу данных,
# то мы Открываем (но, не запускаем) наше приложение
#   with - открытие "файла" и автоматическое закрытие
#   app.app_context() =  create_app().app_context()
# и запускаем нужную функцию от его (Приложения Фласк) имени.
# Т.е. нам не надо запускать само приложение, а только залезть в него,
# со стороны. Для этого используем
# и т.к. нам надо залезть во внутрь Приложения (чтобы от его имени,
# изнутри, запускать), то метод .app_context()
# и тепер зайдя под Казырек (эгиду, Имя) приложения -
# запускаем нужную нам функцию, которй при работе нужна
# flask-sqlalchemy

# Импортируем нашу функцию по созданию нашего приложения
# Им-ем нашу функцию по получению новостей


from webapp import create_app
from webapp.python_org_news import get_python_news

# Объявляемя, что переменная app теперь функция (по вызову нашего Прилжения)
# "создаем апликейшн"
app = create_app()

# context - пока непонятная хрень, но суть в том, что она сейчас нужна,
# чтобы достать аргументы (методы) внутри приложения именно Flask,
#  иначе они считаются локальными переменными фунции,
#  и их нельзя вытаскивать, что логично при таком расскладе.
#
# Но непонятно, зачем ??? мы тогда тянем
# from webapp.python_org_news import get_python_news, если получили
#  get_python_news через контекст.

# Открыть на чтение! (и закрыть по окончании) наше приложение Flaskа!,
# и запустить объект get_python_news()

with app.app_context():
    get_python_news()
